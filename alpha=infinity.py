# -*- coding: utf-8 -*-
"""Alpha=Infinity.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kcVty-I9sapKWgoHsxj35gUCJyn32aUj
"""

!pip install -q condacolab
import condacolab
condacolab.install()

!pip install pyomo
!pip install gurobipy

!apt-get install -y glpk-utils # does not attain a global optimum
!apt-get install -y coinor-cbc # chosen solver for MILP

!conda install -c conda-forge ipopt -y

!which ipopt

from pyomo.environ import *
import math
import numpy as np
from pyomo.core import Constraint
import random
import gurobipy
import copy
import pandas as pd
import pickle
import time

def build_model_P7(N, params):
    m = ConcreteModel()

    # 1) Index Set
    m.N = Set(initialize=N, ordered=True)

    # 2) Parameters (Hint: We define parameters in Pyomo because, in an iteration-based algorithm, we need to update certain parameters. Pyomo only recognizes them within its defined model, so we use Param to define these parameters.)
    m.Phi_SE  = Param(initialize=params['Phi_SE'], mutable=False)
    m.Phi_EE  = Param(initialize=params['Phi_EE'], mutable=False)
    m.zeta    = Param(initialize=params['zeta'],   mutable=False)
    m.pr      = Param(initialize=params['pr'],     mutable=False)
    m.eps     = Param(initialize=params['eps'],    mutable=False)
    m.Cn      = Param(m.N, initialize=params['Cn'], mutable=False)
    m.B       = Param(initialize=params['B'],      mutable=False)
    m.sigma2  = Param(initialize=params['sigma2'], mutable=False)

    m.Rth     = Param(m.N, initialize=params['Rth'], mutable=False)
    m.Pth     = Param(m.N, initialize=params['Pth'], mutable=False)
    m.fmin    = Param(m.N, initialize=params['fmin'], mutable=False)
    m.fmax    = Param(m.N, initialize=params['fmax'], mutable=False)

    m.g2      = Param(m.N, initialize=params['g2'], mutable=False)
    m.order   = Param(m.N, initialize=params['order'], mutable=False)

    # Mutable Linearization Point for z
    m.zk      = Param(m.N, initialize={n: 0.0 for n in N}, mutable=True)

    # 3) Decision Variables
    m.f = Var(m.N, bounds=lambda mod,n: (mod.fmin[n], mod.fmax[n]))
    m.rho = Var(m.N, domain=Reals)   # ln p_n
    m.z = Var(m.N, domain=Reals)     # new SCA slack for rate
    m.l = Var(domain=Reals)          # common lower-bound rate

    # 4) Objective (16a)
    def obj_rule(mod):
        return (
            -mod.Phi_EE * sum(mod.zeta*exp(mod.rho[n])
                              + mod.pr
                              + mod.eps*mod.f[n]**3
                              for n in mod.N)
            + mod.Phi_SE * mod.l
        )
    m.obj = Objective(rule=obj_rule, sense=1)  # maximize

    # 5) Constraints

    # (16b)
    def c_l_bound(mod,n):
        return mod.l >= log(mod.Rth[n])  if False else mod.l >= mod.Rth[n]
        # note: Rth[n] is already the *rate*, not log-rate
    m.c_l_bound = Constraint(m.N, rule=c_l_bound)

    # (16c)
    def c_power(mod,n):
        return mod.zeta*exp(mod.rho[n]) + mod.pr + mod.eps*mod.f[n]**3 \
               <= mod.Pth[n]
    m.c_power = Constraint(m.N, rule=c_power)

    # (16e)
    def c_sca_lin(mod,n):
        return mod.l <= exp(mod.zk[n]) \
                     + exp(mod.zk[n])*(mod.z[n] - mod.zk[n]) \
                     + mod.f[n]/mod.Cn[n]
    m.c_sca_lin = Constraint(m.N, rule=c_sca_lin)

    # (16f)
    def c_rate(mod,n):
        denom = sum(exp(mod.rho[i])*mod.g2[i]
                    for i in mod.N
                    if mod.order[i] < mod.order[n]) \
                + mod.sigma2
        sinr = exp(mod.rho[n])*mod.g2[n] / denom
        return exp(mod.z[n]) <= mod.B * log(1+sinr)/log(2)
    m.c_rate = Constraint(m.N, rule=c_rate)

    return m

if __name__=='__main__':
    # --- 1) Artificial Problem Data  ---
    N = [1,2,3]
    params = {
        'Phi_SE': 1.0, 'Phi_EE': 0.5,
        'zeta':1e-3, 'pr':0.1, 'eps':1e-27,
        'Cn': {1:1e8,2:1e8,3:1e8},
        'B': 1e6, 'sigma2':1e-9,
        'Rth':{1:1,2:1,3:1},
        'Pth':{1:0.5,2:0.5,3:0.5},
        'fmin':{1:0.5e9,2:0.5e9,3:0.5e9},
        'fmax':{1:2e9,2:2e9,3:2e9},
        'g2':{1:1.0,2:0.8,3:0.5},
        'order':{1:1,2:2,3:3},
    }

    # --- 2) Model Building ---
    model = build_model_P7(N, params)
    solver = SolverFactory('ipopt')
    solver.options['tol'] = 1e-7

    # --- 3) SCA Initialization ---
    zk    = {n: 0.0 for n in N}
    H_prev = None
    max_iter = 50
    tol      = 1e-4

    for it in range(1, max_iter+1):
        # 3a) Updating Linearization Point Param
        for n in N:
            model.zk[n] = zk[n]

        # b) solve P7
        solver.solve(model, tee=False)

        # c) Extracting New z and Objective H_k
        z_new = {n: value(model.z[n]) for n in N}
        H_k   = value(model.obj)
        print(f"[P7] iter {it:2d}, H = {H_k:.6f}")

        # d) Checking Convergence
        if H_prev is not None:
            rel = abs(H_k - H_prev)/abs(H_prev)
            if rel < tol:
                print(f"Converged (ΔH/H<{tol}) at iter {it}")
                break

        # e) Updating Variables and Parameters for Next Round
        H_prev = H_k
        zk     = z_new

    # --- 4) Final Solution ---
    f_opt   = {n: value(model.f[n])   for n in N}
    rho_opt = {n: value(model.rho[n]) for n in N}
    z_opt   = zk
    l_opt   = value(model.l)

    print("→ f*   :", f_opt)
    print("→ p*   :", {n: math.exp(rho_opt[n]) for n in N})
    print("→ z*   :", z_opt)
    print("→ l*   :", l_opt)
    print("→ H*   :", H_k)

