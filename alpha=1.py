# -*- coding: utf-8 -*-
"""Alpha=1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15HUYla1lfR5qwlffmuufnZY82jrV0LOh
"""

!pip install -q condacolab
import condacolab
condacolab.install()

!pip install pyomo
!pip install gurobipy

!apt-get install -y glpk-utils # does not attain a global optimum
!apt-get install -y coinor-cbc # chosen solver for MILP

!conda install -c conda-forge ipopt -y

!which ipopt

from pyomo.environ import *
import math
import numpy as np
from pyomo.core import Constraint
import random
import gurobipy
import copy
import pandas as pd
import pickle
import time

def build_model(N, params):
    m = ConcreteModel()

    # 1) Index set
    m.N = Set(initialize=N, ordered=True)

    # 2) Parameters (constants)
    m.Phi_SE  = Param(initialize=params['Phi_SE'], mutable=False)
    m.Phi_EE  = Param(initialize=params['Phi_EE'], mutable=False)
    m.zeta    = Param(initialize=params['zeta'],   mutable=False)
    m.pr      = Param(initialize=params['pr'],     mutable=False)
    m.eps     = Param(initialize=params['eps'],    mutable=False)
    m.Cn      = Param(m.N, initialize=params['Cn'], mutable=False)
    m.B       = Param(initialize=params['B'],      mutable=False)
    m.sigma2  = Param(initialize=params['sigma2'], mutable=False)

    m.Rth     = Param(m.N, initialize=params['Rth'], mutable=False)
    m.Pth     = Param(m.N, initialize=params['Pth'], mutable=False)
    m.fmin    = Param(m.N, initialize=params['fmin'], mutable=False)
    m.fmax    = Param(m.N, initialize=params['fmax'], mutable=False)

    m.g2      = Param(m.N, initialize=params['g2'], mutable=False)
    m.order   = Param(m.N, initialize=params['order'], mutable=False)

    # This is the SCA linearization point, updated each iter:
    m.xk      = Param(m.N, initialize={n: 0.0 for n in N},
                      mutable=True)

    # 3) Variables
    m.f   = Var(m.N, bounds=lambda mod,n: (mod.fmin[n], mod.fmax[n]))
    m.rho = Var(m.N, domain=Reals)   # log(p_n)
    m.a   = Var(m.N, domain=Reals)   # aux. rate
    m.x   = Var(m.N, domain=Reals)   # new SCA slack

    # 4) Objective
    def obj_rule(mod):
        return mod.Phi_SE * sum(mod.a[n] for n in mod.N) \
             - mod.Phi_EE * sum(mod.zeta*exp(mod.rho[n])
                                + mod.pr
                                + mod.eps*mod.f[n]**3
                                for n in mod.N)
    m.obj = Objective(rule=obj_rule, sense=1)  # maximize

    # 5) Constraints
    def c_rate_min(mod,n):
        return mod.a[n] >= log(mod.Rth[n])
    m.c_rate_min = Constraint(m.N, rule=c_rate_min)

    def c_power_cap(mod,n):
        return mod.zeta*exp(mod.rho[n]) + mod.pr + mod.eps*mod.f[n]**3 \
               <= mod.Pth[n]
    m.c_power_cap = Constraint(m.N, rule=c_power_cap)

    def c_sca_linear(mod,n):
        # first‐order Taylor of exp(a)-f/Cn at xk:
        return exp(mod.a[n]) - mod.f[n]/mod.Cn[n] \
             <= exp(mod.xk[n]) + exp(mod.xk[n])*(mod.x[n] - mod.xk[n])
    m.c_sca_linear = Constraint(m.N, rule=c_sca_linear)

    def c_rate_sca(mod,n):
        # build NOMA‐SIC denominator
        denom = sum(exp(mod.rho[i])*mod.g2[i]
                    for i in mod.N
                    if mod.order[i] < mod.order[n]) \
                + mod.sigma2
        sinr = exp(mod.rho[n])*mod.g2[n]/denom
        # log2 => ln/ln2
        return exp(mod.x[n]) <= mod.B*log(1+sinr)/log(2)
    m.c_rate_sca = Constraint(m.N, rule=c_rate_sca)

    return m

if __name__=='__main__':
    # --- 1) Artificial Problem Data  ---
    N = [1,2,3]   # example 3 users
    params = {
        'Phi_SE': 1.0, 'Phi_EE': 0.5,
        'zeta':1e-3, 'pr':0.1, 'eps':1e-27,
        'Cn': {1:1e8,2:1e8,3:1e8},
        'B': 1e6, 'sigma2':1e-9,
        'Rth':{1:1,2:1,3:1},
        'Pth':{1:0.5,2:0.5,3:0.5},
        'fmin':{1:0.5e9,2:0.5e9,3:0.5e9},
        'fmax':{1:2e9,2:2e9,3:2e9},
        'g2':{1:1.0,2:0.8,3:0.5},
        'order':{1:1,2:2,3:3},
    }

    # --- 2) Model Building ---
    model = build_model(N, params)
    solver = SolverFactory('ipopt')
    solver.options['tol'] = 1e-7

    # --- 3) SCA Initialization ---
    xk = {n: 0.0 for n in N}
    max_iter = 20
    tol = 1e-4

    for it in range(1, max_iter+1):
        # 3a) Updating Linearization Point Param
        for n in N:
            model.xk[n] = xk[n]

        # 3b) Solving the Convex Subproblem
        result = solver.solve(model, tee=False)

        # 3c) Extracting New x and Objective
        x_new = {n: value(model.x[n]) for n in N}
        obj_val = value(model.obj)

        # 3d) Checking Convergence
        diff = max(abs(x_new[n] - xk[n]) for n in N)
        print(f"Iter {it}: obj = {obj_val:.6f}, ||Δx||_∞ = {diff:.6e}")
        if diff < tol:
            print("Converged!")
            break

        # 3e) Update Variables and Parameters for Next Round
        xk = x_new

    # --- 4) Final Solution ---
    f_opt   = {n: value(model.f[n])   for n in N}
    rho_opt = {n: value(model.rho[n]) for n in N}
    a_opt   = {n: value(model.a[n])   for n in N}
    x_opt   = xk

    print("f*:   ", f_opt)
    print("rho*:", rho_opt)
    print("a*:   ", a_opt)
    print("x*:   ", x_opt)